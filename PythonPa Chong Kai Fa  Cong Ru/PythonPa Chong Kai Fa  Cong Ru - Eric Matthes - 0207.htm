<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
	"http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="generator" content="ABBYY FineReader PDF 15">
<style type="text/css">
 table.main {}
 tr.row {}
 td.cell {}
 div.block {}
 div.paragraph {}
 .font0 { font:8pt Arial, sans-serif; }
 .font1 { font:10pt Arial, sans-serif; }
 .font2 { font:12pt Arial, sans-serif; }
 .font3 { font:10pt Segoe UI, sans-serif; }
 .font4 { font:10pt SimHei, sans-serif; }
 .font5 { font:12pt SimHei, sans-serif; }
 .font6 { font:8pt SimSun, serif; }
 .font7 { font:10pt SimSun, serif; }
 .font8 { font:9pt Times New Roman, serif; }
 .font9 { font:10pt Times New Roman, serif; }
 .font10 { font:11pt Times New Roman, serif; }

</style>
</head>
<body>
<p><span class="font9">190</span></p>
<p><span class="font7">第</span><span class="font9">11</span><span class="font7">章 测试代码</span></p>
<p><span class="font7">第</span><span class="font9">1</span><span class="font7">行的句点表明有一个测试通过了。接下来的一行指出</span><span class="font9">Python</span><span class="font7">运行了一个测试，消耗的时 间不到</span><span class="font9">0.001</span><span class="font7">秒。最后的</span><span class="font3">OK</span><span class="font7">表明该测试用例中的所有单元测试都通过了。</span></p>
<p><span class="font7">上述输出表明，给定包含名和姓的姓名时，函数</span><span class="font3">get_formatted_name()</span><span class="font7">总是能正确地处理。 修改</span><span class="font3">get_formatted_name</span><span class="font7">。后，可再次运行这个测试用例。如果它通过了，我们就知道在给定</span><span class="font3">Janis Joplin</span><span class="font7">这样的姓名时，这个函数依然能够正确地处理。</span></p>
<ul style="list-style:none;"><li><a name="caption1"></a>
<h5><a name="bookmark0"></a><span class="font2"><a name="bookmark1"></a>11.1.3</span><span class="font5"> 不能通过的测试</span></h5></li></ul>
<p><span class="font7">测试未通过时结果是什么样的呢？我们来修改</span><span class="font3">get_formatted_name()</span><span class="font7">，使其能够处理中间名， 但这样做时，故意让这个函数无法正确地处理像</span><span class="font9">Janis Joplin</span><span class="font7">这样只有名和姓的姓名。</span></p>
<p><span class="font7">下面是函数</span><span class="font3">get_formatted_name()</span><span class="font7">的新版本，它要求通过一个实参指定中间名：</span></p>
<p><span class="font1">name_ function.py</span></p>
<p><span class="font0">def get_formatted_name(first, middle, last):</span></p>
<p><span class="font8">&quot;&quot;&quot;</span><span class="font6">生成整洁的姓名</span><span class="font8">&quot;&quot;&quot;</span></p>
<p><span class="font0">full_name = first + ' ' + middle + ' ' + last</span></p>
<p><span class="font0">return full_name.title()</span></p>
<p><span class="font7">这个版本应该能够正确地处理包含中间名的姓名，但对其进行测试时，我们发现它再也不能 正确地处理只有名和姓的姓名。这次运行程序</span><span class="font9">test_name_function.py</span><span class="font7">时，输出如下：</span></p>
<p><span class="font0" style="font-weight:bold;">O </span><span class="font0">E</span></p>
<p><span class="font0">======================================================================</span></p>
<p><span class="font0" style="font-weight:bold;">❷ </span><span class="font0">ERROR: test_first_last_name (—main—.NamesTestCase)</span></p>
<p><span class="font0">----------------------------------------------------------------------</span></p>
<p><span class="font0" style="font-weight:bold;">❸ </span><span class="font0">Traceback (most recent call last):</span></p>
<p><span class="font0">File &quot;test_name_function.py&quot;, line 8, in test_first_last_name</span></p>
<p><span class="font0">formatted_name = get_formatted_name('janis', 'joplin')</span></p>
<p><span class="font0">TypeError: get_formatted_name() missing 1 required positional argument: 'last'</span></p>
<p><span class="font0" style="font-weight:bold;">❹ </span><span class="font0">Ran 1 test in 0.000s</span></p>
<p><span class="font0" style="font-weight:bold;">❺ </span><span class="font0">FAILED (errors=1)</span></p>
<p><span class="font7">其中包含的信息很多，因为测试未通过时，需要让你知道的事情可能有很多。第</span><span class="font9">1</span><span class="font7">行输出只 有一个字母</span><span class="font3">E </span><span class="font7">(见</span><span class="font10" style="font-weight:bold;">O</span><span class="font7">)，它指出测试用例中有一个单元测试导致了错误。接下来，我们看到 </span><span class="font3">NamesTestCase</span><span class="font7">中的</span><span class="font3">test_first_last_name()</span><span class="font7">导致了错误(见</span><span class="font4">❷</span><span class="font7">)。测试用例包含众多单元测试时， 知道哪个测试未通过至关重要。在</span><span class="font4">❸</span><span class="font7">处，我们看到了一个标准的</span><span class="font9">traceback</span><span class="font7">，它指出函数调用 </span><span class="font3">get_formatted_name(janis', joplin')</span><span class="font7">有问题，因为它缺少一个必不可少的位置实参。</span></p>
<p><span class="font7">我们还看到运行了一个单元测试(见</span><span class="font4">❹</span><span class="font7">)。最后，还看到了一条消息，它指出整个测试用例 都未通过，因为运行该测试用例时发生了一个错误(见</span><span class="font4">❺</span><span class="font7">)。这条消息位于输出末尾，让你一眼 就能看到</span><span class="font9">——</span><span class="font7">你可不希望为获悉有多少测试未通过而翻阅长长的输出。</span></p>
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
<div>
</div><br clear="all">
</body>
</html>